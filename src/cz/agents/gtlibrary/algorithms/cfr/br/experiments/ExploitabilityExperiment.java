package cz.agents.gtlibrary.algorithms.cfr.br.experiments;

import cz.agents.gtlibrary.algorithms.cfr.br.CFRBR;
import cz.agents.gtlibrary.algorithms.cfr.br.responses.*;
import cz.agents.gtlibrary.algorithms.mcts.MCTSConfig;
import cz.agents.gtlibrary.algorithms.mcts.MCTSInformationSet;
import cz.agents.gtlibrary.algorithms.sequenceform.gensum.experiments.StrategyStrengthLargeExperiments;
import cz.agents.gtlibrary.domain.flipit.*;
import cz.agents.gtlibrary.interfaces.GameState;
import cz.agents.gtlibrary.utils.HighQualityRandom;
import cz.agents.gtlibrary.utils.graph.Graph;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.lang.management.ManagementFactory;
import java.lang.management.ThreadMXBean;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;

/**
 * Created by Jakub Cerny on 06/06/2018.
 */
public class ExploitabilityExperiment {

    public static void main(String[] args) {
        if(args.length > 0){
            if(args[0].equals("F"))
                runFlipIt(args);
            if(args[0].equals("E"))
                runFlipItExploitation(args);
        }
        else{
//            runFlipItExploitation(new String[]{"F", "3", "5", "F", "-1", "1", "200", "P", "attackerstrategy0.txt"});
            runFlipItExploitation(new String[]{"F", "3", "5", "F", "-1", "0", "200", "R", "attackerstrategy0.txt"});
//            runFlipIt(new String[]{"F", "4", "3", "AP", "-1", "1", "200", "Q", "0.4", "P", "Q", "0.01", "Q", "0.2"});
        }
    }

    public static void runFlipIt(String[] args){
        FlipItGameInfo gameInfo;
        int seed = 10;
        String responseVersion = "P";
        ArrayList<String> responseVersionExploiting = new ArrayList<>();
        ArrayList<Double> lambdaExploiting = new ArrayList<>();
        int BRplayer = 1;
        int iterations = 100000;
        double lambda = 0.001;

        if (args.length == 0)
            gameInfo = new FlipItGameInfo();
        else {
            int depth = Integer.parseInt(args[1]);
            String graphSize = args[2];
            String graphFile = "flipit_empty" + graphSize + ".txt";
//            String graphFile = (graphSize == 3 ) ? "flipit_empty3.txt" : (graphSize == 4 ? "flipit_empty4.txt" : (graphSize == 5 ? "flipit_empty5.txt" : ""));
            gameInfo = new FlipItGameInfo(depth, 1, graphFile, 1);
            FlipItGameInfo.OUTPUT_STRATEGY = false;
            if (args.length > 3) {
                String version = args[3];
                switch (version) {
                    case "F":
                        FlipItGameInfo.gameVersion = FlipItGameInfo.FlipItInfo.FULL;
                        break;
                    case "N":
                        FlipItGameInfo.gameVersion = FlipItGameInfo.FlipItInfo.NO;
                        break;
                    case "NP":
                        FlipItGameInfo.gameVersion = FlipItGameInfo.FlipItInfo.REVEALED_NODE_POINTS;
                        break;
                    case "AP":
                        FlipItGameInfo.gameVersion = FlipItGameInfo.FlipItInfo.REVEALED_ALL_POINTS;
                        break;//
                }
            }
            if(args.length > 4){
                seed = Integer.parseInt(args[4]);
            }
            if(args.length > 5){
                BRplayer = Integer.parseInt(args[5]);
            }
            if(args.length > 6){
                iterations = Integer.parseInt(args[6]);
            }
            if(args.length > 7){
                responseVersion = args[7];
            }
            int idx = 0;
            if(responseVersion.equals("Q")){
                lambda = Double.parseDouble(args[8]);
                idx=9;
            }
            else{
                idx=8;
            }
            while(args.length > idx){
                String attackerType = args[idx];
                responseVersionExploiting.add(attackerType);
                idx++;
                if(attackerType.equals("Q")){
                    lambdaExploiting.add(Double.parseDouble(args[idx]));
                    idx++;
                }
                else{
                    lambdaExploiting.add(0.0);
                }
            }


        }
        gameInfo.ZERO_SUM_APPROX = true;
        gameInfo.ENABLE_PASS = true;
        GameState rootState;

        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();
        rootState = initGame(gameInfo, seed);

        System.out.println("CFR BR. Setting: ");
        System.out.println("BR Player = " + gameInfo.getAllPlayers()[BRplayer] + ", BR Type = " + responseVersion);
        if (responseVersion == "Q"){
            System.out.println("Response setting: Lambda = " + lambda);
        }
        System.out.println(gameInfo.getInfo());

        FlipItExpander<MCTSInformationSet> expander = new FlipItExpander<>(new MCTSConfig());

        CFRBR cfr = new CFRBR(rootState.getAllPlayers()[1-BRplayer], rootState, expander, BRplayer);
        StrategyStrengthLargeExperiments.buildCFRBRCompleteTree(cfr.getRootNode(), BRplayer);

        BestResponse response = null;
        switch (responseVersion) {
            case "P":
                response = new PureResponse(rootState.getAllPlayers()[BRplayer],
                        cfr.getRootNode());
                break;
            case "Q":
                response = new QuantalResponse(rootState.getAllPlayers()[BRplayer],
                        cfr.getRootNode(), lambda);
                break;
        }

        long brTime = 0;
        long cfrTime = 0;
        long startTime;
        double cfrValue = 0.0, brValue;
        BestResponse exploitingResponse = null;

        int cycle = -1;
        while(true) {
            cycle++;
            for (int i = 0; i < iterations; i++) {
                startTime = threadBean.getCurrentThreadCpuTime();
                brValue = cfr.runBRIteration(response);
                brTime += (threadBean.getCurrentThreadCpuTime() - startTime) / 1000000l;
                startTime = threadBean.getCurrentThreadCpuTime();
                cfrValue = cfr.runCFRIteration();
                cfrTime += (threadBean.getCurrentThreadCpuTime() - startTime) / 1000000l;
                if (i % 100 == 0) printStatistics(brTime, cfrTime, i+cycle*iterations, cfrValue, brValue);
            }
            for (int attackerIdx = 0; attackerIdx < responseVersionExploiting.size(); attackerIdx++) {
                switch (responseVersionExploiting.get(attackerIdx)) {
                    case "P":
                        exploitingResponse = new PureResponse(rootState.getAllPlayers()[BRplayer],
                                cfr.getRootNode());
                        ((PureResponse) exploitingResponse).setIteration(-attackerIdx - 1);
                        break;
                    case "Q":
                        exploitingResponse = new QuantalResponse(rootState.getAllPlayers()[BRplayer],
                                cfr.getRootNode(), lambdaExploiting.get(attackerIdx));
                        ((QuantalResponse) exploitingResponse).setIteration(-attackerIdx - 1);
                        break;
                }
                System.out.println("\n __________EXPLOITING!");
                System.out.println("Exploiting Player = " + gameInfo.getAllPlayers()[BRplayer] + ", BR Type = " + responseVersionExploiting.get(attackerIdx));
                if (responseVersionExploiting.get(attackerIdx).equals("Q")) {
                    System.out.println("Exploiting setting: Lambda = " + lambdaExploiting.get(attackerIdx));
                }
                startTime = threadBean.getCurrentThreadCpuTime();
                //cfrValue = cfr.runCFRIteration();
                cfrTime += (threadBean.getCurrentThreadCpuTime() - startTime) / 1000000l;
                startTime = threadBean.getCurrentThreadCpuTime();
                brValue = cfr.runBRIteration(exploitingResponse);
                brTime += (threadBean.getCurrentThreadCpuTime() - startTime) / 1000000l;
                printStatistics(brTime, cfrTime, iterations, cfrValue, brValue);
            }
            System.out.println("\n\n*******************************************\n");
            cfr.runBRIteration(response);
        }
    }

    protected static void printStatistics(long brTime, long cfrTime, int iteration, double cfrValue, double brValue){
        String timeStamp = new SimpleDateFormat("HH:mm:ss").format(Calendar.getInstance().getTime());
        System.out.println("Iteration " + iteration);
        System.out.println("\t time = " + timeStamp);
        System.out.println("\t cfr value = " + cfrValue);
        System.out.println("\t br value  = " + brValue);
        System.out.println("\t average brtime  = " + ((double)brTime / (iteration+1)));
        System.out.println("\t average cfrtime = " + ((double)cfrTime / (iteration+1)));
        System.out.println("\t full brtime     = " + brTime);
        System.out.println("\t full cfrtime    = " + cfrTime);
    }

    protected static GameState initGame(FlipItGameInfo gameInfo, int seed) {

        int rounding = 3;
        final double MAX_COST = 10, MAX_REWARD = 10;//MAX_COST;
        int numberOfNodes = (new Graph(gameInfo.graphFile)).getAllNodes().size();//Integer.parseInt(gameInfo.graphFile.substring(gameInfo.graphFile.length() - 5, gameInfo.graphFile.length() - 4));
//        System.out.println(numberOfNodes);
        HighQualityRandom random = new HighQualityRandom(seed);
        double[] costs = new double[numberOfNodes];
        double[] rewards = new double[numberOfNodes];
        for (int i = 0; i < numberOfNodes; i++) {
            int type = random.nextInt(4);
            switch (type) {
                // HW [6..10], HC[6..10]
                case 0:
                    costs[i] = 6 + random.nextInt(5);
                    rewards[i] = 6 + random.nextInt(5);
                    break;
                // HW[6..10], LC[3..6]
                case 1:
                    costs[i] = 3 + random.nextInt(4);
                    rewards[i] = 6 + random.nextInt(5);
                    break;
                // LW[3..6], HC[5..9]
                case 2:
                    costs[i] = 5 + random.nextInt(5);
                    rewards[i] = 3 + random.nextInt(4);
                    break;
                // LW[1..4], LC[1..4]
                case 3:
                    costs[i] = 1 + random.nextInt(4);
                    rewards[i] = 1 + random.nextInt(4);
                    break;
            }

//            costs[i] = Math.round(((int) Math.pow(10, rounding)) * MAX_COST * random.nextDouble()) / Math.pow(10, rounding);
//            rewards[i] = Math.round(((int) Math.pow(10, rounding)) * MAX_REWARD * random.nextDouble()) / Math.pow(10, rounding);
        }

        if (seed != -1) {
            gameInfo.graph = new FlipItGraph(gameInfo.graphFile, costs, rewards);
        }
        else{
            gameInfo.graph = new FlipItGraph(gameInfo.graphFile);
        }

        GameState rootState = null;
        if (FlipItGameInfo.CALCULATE_UTILITY_BOUNDS) gameInfo.calculateMinMaxBounds();

        switch (FlipItGameInfo.gameVersion) {
            case NO:
                rootState = new NoInfoFlipItGameState();
                break;
            case FULL:
                rootState = new FullInfoFlipItGameState();
                break;
            case REVEALED_ALL_POINTS:
                rootState = new AllPointsFlipItGameState();
                break;
            case REVEALED_NODE_POINTS:
                rootState = new NodePointsFlipItGameState();
                break;

        }
        return rootState;
    }


    protected static void runFlipItExploitation(String[] args){
        FlipItGameInfo gameInfo;
        int seed = 10;
        String responseVersion = "P";
        ArrayList<String> responseVersionExploiting = new ArrayList<>();
        ArrayList<Double> lambdaExploiting = new ArrayList<>();
        int BRplayer = 1;
        int iterations = 100000;
        String strategyFile = "";

        if (args.length == 0)
            gameInfo = new FlipItGameInfo();
        else {
            int depth = Integer.parseInt(args[1]);
            String graphSize = args[2];
            String graphFile = "flipit_empty" + graphSize + ".txt";
//            String graphFile = (graphSize == 3 ) ? "flipit_empty3.txt" : (graphSize == 4 ? "flipit_empty4.txt" : (graphSize == 5 ? "flipit_empty5.txt" : ""));
            gameInfo = new FlipItGameInfo(depth, 1, graphFile, 1);
            FlipItGameInfo.OUTPUT_STRATEGY = false;
            if (args.length > 3) {
                String version = args[3];
                switch (version) {
                    case "F":
                        FlipItGameInfo.gameVersion = FlipItGameInfo.FlipItInfo.FULL;
                        break;
                    case "N":
                        FlipItGameInfo.gameVersion = FlipItGameInfo.FlipItInfo.NO;
                        break;
                    case "NP":
                        FlipItGameInfo.gameVersion = FlipItGameInfo.FlipItInfo.REVEALED_NODE_POINTS;
                        break;
                    case "AP":
                        FlipItGameInfo.gameVersion = FlipItGameInfo.FlipItInfo.REVEALED_ALL_POINTS;
                        break;//
                }
            }
            if (args.length > 4) {
                seed = Integer.parseInt(args[4]);
            }
            if (args.length > 5) {
                BRplayer = Integer.parseInt(args[5]);
            }
            if (args.length > 6) {
                iterations = Integer.parseInt(args[6]);
            }
            if (args.length > 7) {
                responseVersion = args[7];
            }
            if (args.length > 8) {
                strategyFile = args[8];
            }
        }

        gameInfo.ZERO_SUM_APPROX = true;
        gameInfo.ENABLE_PASS = true;
        GameState rootState;

        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();
        rootState = initGame(gameInfo, seed);

        System.out.println("CFR BR. Setting: ");
        System.out.println("BR Player = " + gameInfo.getAllPlayers()[BRplayer] + ", BR Type = " + responseVersion);
        System.out.println(gameInfo.getInfo());

        FlipItExpander<MCTSInformationSet> expander = new FlipItExpander<>(new MCTSConfig());

        CFRBR cfr = new CFRBR(rootState.getAllPlayers()[1-BRplayer], rootState, expander, BRplayer);
        StrategyStrengthLargeExperiments.buildCFRBRCompleteTree(cfr.getRootNode(), BRplayer);

        HashMap<String,HashMap<String,HashMap<String,Double>>> strategy = readStrategy(strategyFile);

        BestResponse response = null;
        switch (responseVersion) {
            case "P":
                response = new PartialPureResponse(rootState.getAllPlayers()[BRplayer],
                        cfr.getRootNode(), strategy);
                break;
            case "R":
                response = new RestrictivePureResponse(rootState.getAllPlayers()[BRplayer],
                        cfr.getRootNode(), strategy);
                break;
        }

        long brTime = 0;
        long cfrTime = 0;
        long startTime;
        double cfrValue = 0.0, brValue;
//        BestResponse exploitingResponse = null;

        if(responseVersion.equals("P")){
            for (int i = 0; i < iterations + 1; i++) {
                startTime = threadBean.getCurrentThreadCpuTime();
                brValue = cfr.runBRIteration(response);
                brTime += (threadBean.getCurrentThreadCpuTime() - startTime) / 1000000l;
                startTime = threadBean.getCurrentThreadCpuTime();
                cfrValue = cfr.runCFRIteration();
                cfrTime += (threadBean.getCurrentThreadCpuTime() - startTime) / 1000000l;
                if (i % 100 == 0) printStatistics(brTime, cfrTime, i, cfrValue, brValue);
            }
        }


        if(responseVersion.equals("R")){
            startTime = threadBean.getCurrentThreadCpuTime();
            brValue = cfr.runBRIteration(response);
            brTime += (threadBean.getCurrentThreadCpuTime() - startTime) / 1000000l;
            printStatistics(brTime, cfrTime, 0, cfrValue, brValue);
        }
    }


    protected static HashMap<String,HashMap<String,HashMap<String,Double>>> readStrategy(String strategyFile){

        System.out.println("Reading file: " + strategyFile);
        HashMap<String,HashMap<String,HashMap<String,Double>>> strategy = new HashMap<>();
//        String strategyFile = "attackerstrategy0.txt";
        try (BufferedReader br = new BufferedReader(new FileReader(strategyFile))) {
            String line;
            String defStrategy = null;
            String attStrategy = null;
            while ((line = br.readLine()) != null) {
                // process the line.
                String[] tokens = line.split(" ");
                if(tokens[0].equals("Sequence:")){
                    defStrategy = tokens[1];
                    attStrategy = tokens[2];
                    if(!strategy.containsKey(defStrategy))
                        strategy.put(defStrategy, new HashMap<>());
                    if(!strategy.get(defStrategy).containsKey(attStrategy))
                        strategy.get(defStrategy).put(attStrategy, new HashMap<>());
                    continue;
                }
                if(!tokens[0].equals("Strategy:")){
                    double val = Double.parseDouble(tokens[1]);
                    if(val > 0.0){
                        String node = tokens[0].substring(0,1);
                        strategy.get(defStrategy).get(attStrategy).put(node, val);
                    }
                    else{
                        if(val > 0.0) System.out.println(val);
                    }
                }

            }
//            System.out.println(defStrategy + " / " + attStrategy + " : " + strategy.get(defStrategy).get(attStrategy).toString());
        } catch (IOException e) {
            e.printStackTrace();
        }
        checkStrategyInDepth(strategy,4,6);
        checkStrategyInDepth(strategy,3,6);
        checkStrategyInDepth(strategy,2,6);
        checkStrategyInDepth(strategy,1,6);
        return strategy;
    }

    protected static void checkStrategyInDepth(HashMap<String,HashMap<String,HashMap<String,Double>>> strategy, int depth, int numActions){
        for(String def : strategy.keySet()){
            if(def.split(",").length == depth){
                for(String att: strategy.get(def).keySet()){
                    if(att.split(",").length == depth){
                        boolean hasContinuation = false;
                        for(int defAction = 0; defAction < numActions; defAction++){
                            String defCont = def + "," + defAction;
                            if(!strategy.containsKey(defCont)) continue;
                            if(strategy.containsKey(defCont)){
                                boolean isContinuation = true;
                                for(String attAction : strategy.get(def).get(att).keySet()){
                                    String attCont = att + "," + attAction;
                                    if(!strategy.get(defCont).containsKey(attCont)){
                                        isContinuation = false;
                                        break;
                                    }
                                }
                                if (isContinuation){
                                    hasContinuation = true;
                                    break;
                                }
                            }
                        }
                        if(!hasContinuation){
                            System.out.println("Current IS has no continuation: " + def + " / " + att);
                            System.out.println("Attackers actions: " + strategy.get(def).get(att).keySet().toString());
                        }
                    }
                }
            }
        }
    }
}
