/*
Copyright 2014 Faculty of Electrical Engineering at CTU in Prague

This file is part of Game Theoretic Library.

Game Theoretic Library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Game Theoretic Library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Game Theoretic Library.  If not, see <http://www.gnu.org/licenses/>.*/


/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package cz.agents.gtlibrary.algorithms.mcts;

import cz.agents.gtlibrary.algorithms.mcts.distribution.Distribution;
import cz.agents.gtlibrary.algorithms.mcts.distribution.FrequenceDistribution;
import cz.agents.gtlibrary.algorithms.mcts.distribution.StrategyCollector;
import cz.agents.gtlibrary.algorithms.mcts.nodes.InnerNode;
import cz.agents.gtlibrary.algorithms.mcts.nodes.Node;
import cz.agents.gtlibrary.algorithms.mcts.selectstrat.UCTBackPropFactory;
import cz.agents.gtlibrary.algorithms.sequenceform.FullSequenceEFG;
import cz.agents.gtlibrary.algorithms.sequenceform.SQFBestResponseAlgorithm;
import cz.agents.gtlibrary.algorithms.sequenceform.SequenceFormConfig;
import cz.agents.gtlibrary.algorithms.sequenceform.SequenceInformationSet;
import cz.agents.gtlibrary.domain.goofspiel.GSGameInfo;
import cz.agents.gtlibrary.domain.goofspiel.GoofSpielExpander;
import cz.agents.gtlibrary.domain.goofspiel.IIGoofSpielGameState;
import cz.agents.gtlibrary.domain.phantomTTT.TTTExpander;
import cz.agents.gtlibrary.domain.phantomTTT.TTTInfo;
import cz.agents.gtlibrary.domain.phantomTTT.TTTState;
import cz.agents.gtlibrary.domain.randomgame.RandomGameExpander;
import cz.agents.gtlibrary.domain.randomgame.RandomGameInfo;
import cz.agents.gtlibrary.domain.randomgame.RandomGameState;
import cz.agents.gtlibrary.iinodes.ArrayListSequenceImpl;
import cz.agents.gtlibrary.iinodes.ConfigImpl;
import cz.agents.gtlibrary.interfaces.*;
import cz.agents.gtlibrary.utils.io.GambitEFG;
import cz.agents.gtlibrary.strategy.Strategy;
import cz.agents.gtlibrary.strategy.UniformStrategyForMissingSequences;
import java.io.PrintStream;
import java.util.*;

/**
 *
 * @author vilo
 */
public class ISMCTSExploitability {
        private static final int MCTS_MILISECONDS_PER_CALL = 1000;
	private static PrintStream out = System.out;
    
        
        static public GameInfo gameInfo;
        static public GameState rootState;
        static public SequenceFormConfig<SequenceInformationSet> sfAlgConfig;
        static public Expander<SequenceInformationSet> sfExpander;
        static public Expander<MCTSInformationSet> expander;
        static public FullSequenceEFG efg;
        static public Map<Player, Map<Sequence, Double>> optStrategies;
        static public SQFBestResponseAlgorithm brAlg0;
        static public SQFBestResponseAlgorithm brAlg1;
        
        public static void setupPTTT(){
            gameInfo = new TTTInfo();
            rootState = new TTTState();
            expander = new TTTExpander<MCTSInformationSet> (new MCTSConfig());
            expander.getAlgorithmConfig().createInformationSetFor(rootState);
//            sfAlgConfig = new SequenceFormConfig<SequenceInformationSet>();
//            sfExpander = new TTTExpander<SequenceInformationSet>(sfAlgConfig);
//            efg = new FullSequenceEFG(rootState, sfExpander , gameInfo, sfAlgConfig);
//            efg.generateCompleteGame();
//            SMMCTSExperiment.printRootDistribution(optStrategies.get(rootState.getAllPlayers()[1]));
//            System.out.println();
//            brAlg0 = new SQFBestResponseAlgorithm(sfExpander, 0, new Player[] { rootState.getAllPlayers()[0], rootState.getAllPlayers()[1] }, sfAlgConfig, gameInfo);
//            brAlg1 = new SQFBestResponseAlgorithm(sfExpander, 1, new Player[] { rootState.getAllPlayers()[0], rootState.getAllPlayers()[1] }, sfAlgConfig, gameInfo);
        }
        
        public static void setupIIGoofSpiel(){
            gameInfo = new GSGameInfo();
            rootState = new IIGoofSpielGameState();
            expander = new GoofSpielExpander<MCTSInformationSet> (new MCTSConfig());
            expander.getAlgorithmConfig().createInformationSetFor(rootState);
        }

         public static void setupRnd(long seed){
            gameInfo = new RandomGameInfo();
            rootState = new RandomGameState();
            expander = new RandomGameExpander<MCTSInformationSet> (new MCTSConfig());
            expander.getAlgorithmConfig().createInformationSetFor(rootState);
            
            if (seed == RandomGameInfo.seed && rootState != null) return;
            RandomGameInfo.seed = seed;
            sfAlgConfig = new SequenceFormConfig<SequenceInformationSet>();
            sfExpander = new RandomGameExpander<SequenceInformationSet>(sfAlgConfig);
            efg = new FullSequenceEFG(rootState, sfExpander , gameInfo, sfAlgConfig);
            optStrategies = efg.generate();
            System.out.println("BR:" + exploitability(optStrategies.get(rootState.getPlayerToMove())));
             new GambitEFG().write("RND" + RandomGameInfo.MAX_BF + RandomGameInfo.MAX_DEPTH + "_" +seed+".efg", rootState, sfExpander);
        }
        
        static final double gamma = 0.6;
        static final UCTBackPropFactory fact = new UCTBackPropFactory(2);
        static MCTSConfig firstMCTSConfig;// = new MCTSConfig(new DefaultSimulator(), fact, new UniformStrategyForMissingSequences.Factory(), null);
        static Distribution dist = new FrequenceDistribution(); //MostFrequentAction();//


    //static MCTSRunner runner;
    static public ISMCTSAlgorithm alg;
    static Strategy strategy = new UniformStrategyForMissingSequences.Factory().create();
        static HashSet<MCTSInformationSet> processed = new HashSet();
        public static void buildStichedStrategy(Player pl, MCTSInformationSet parentIS, InnerNode curNode) throws Exception {
            MCTSInformationSet curNodeIS = curNode.getInformationSet();
            if (curNodeIS.getPlayer().equals(pl) && !processed.contains(curNode.getInformationSet())){
                alg.setCurrentIS(parentIS);
                alg.runMiliseconds(MCTS_MILISECONDS_PER_CALL);
                Map<Action, Double> actionDistribution = dist.getDistributionFor(curNodeIS.getAlgorithmData());
                double prefix = strategy.get(curNodeIS.getPlayersHistory());
                for (Map.Entry<Action, Double> en : actionDistribution.entrySet()){
                    Sequence sq = new ArrayListSequenceImpl(curNodeIS.getPlayersHistory());
                    sq.addLast(en.getKey());
                    strategy.put(sq, en.getValue()*prefix);
                }
                processed.add(curNodeIS);
            } else curNodeIS = parentIS;
            //depth cut-off
            //int depth=0;
            //for (Player p : curNode.getGameState().getAllPlayers())
            //    depth += curNode.getGameState().getHistory().getSequenceOf(p).size();
            //if (depth == 3) return;
            
            for(Node n : curNode.getChildren().values()){
                if (!(n instanceof InnerNode)) continue;
                buildStichedStrategy(pl, curNodeIS, (InnerNode)n);
            }
        }

        public static Map<Sequence, Double> filterLow(Map<Sequence, Double> s){
            for (Iterator<Map.Entry<Sequence, Double>> it = s.entrySet().iterator(); it.hasNext();){
                if (it.next().getValue() < 1e-4) it.remove();
            }
            return s;
        }
        
        
        static Strategy br;
        public static double exploitability(Map<Sequence, Double> strategy){
            Map<Sequence, Double> st = filterLow(strategy);
            //Map<Sequence, Double> st = strategy;
            SQFBestResponseAlgorithm mctsBR = new SQFBestResponseAlgorithm(
                    expander,
                    1-strategy.keySet().iterator().next().getPlayer().getId(),
                    new Player[] { rootState.getAllPlayers()[0], rootState.getAllPlayers()[1] },
                    (ConfigImpl) expander.getAlgorithmConfig(), gameInfo);
            double val = mctsBR.calculateBR(rootState, st);
            br = mctsBR.getBRStategy();
            return -val;
        }
               
        static int playerID=0;
        public static void main(String[] args) throws Exception{
            ArrayList<Strategy> allStrategies = new ArrayList();
            for (int i=0;i<1;i++){                
                //setupRnd(11);
                //setupPTTT();
                setupIIGoofSpiel();
                alg = new ISMCTSAlgorithm(rootState.getAllPlayers()[playerID], new DefaultSimulator(expander), fact, rootState, expander);
                alg.runMiliseconds(100);
                strategy = new UniformStrategyForMissingSequences();
                strategy.put(new ArrayListSequenceImpl(rootState.getAllPlayers()[playerID]), 1.0);
                processed.clear();
                buildStichedStrategy(rootState.getAllPlayers()[0],alg.getRootNode().getInformationSet(), alg.getRootNode());
                allStrategies.add(strategy);
                System.out.print(exploitability(strategy) + " ");
            }
            System.out.println();
            //Strategy mean = UniformStrategyForMissingSequences.computeMeanStrategy(allStrategies, rootState, expander);
            System.out.println("Extracting strategy:" + (new Date()).toString());
            Strategy mean = StrategyCollector.getStrategyFor(alg.getRootNode(), rootState.getAllPlayers()[playerID], dist);
                    
            System.out.println(mean);
            System.out.println();
            System.out.println(mean.fancyToString(rootState, expander, rootState.getAllPlayers()[0]));
            mean.sanityCheck(rootState, expander);
//            System.out.println("Storing strategy.");
//            try {
//                FileOutputStream file = new FileOutputStream("PTTT_ISMCTS_Strategy.ser");
//                ObjectOutputStream stream = new ObjectOutputStream(file);
//                stream.writeObject(mean);
//                stream.close();
//                file.close();
//            } catch (Exception ex){
//                ex.printStackTrace();
//            }
            alg = null;
            System.gc();
            
            System.out.println(exploitability(mean));
            System.out.println();
            System.out.println(br.fancyToString(rootState, expander, rootState.getAllPlayers()[1]));
            //IIGMCTSMatch.setupPTTT();
            IIGMCTSMatch.setupIIGoofSpiel();
            for (;;) IIGMCTSMatch.ISMCTSvsStrategy(br);
            
            //System.out.println(br.fancyToString(rootState, expander, rootState.getAllPlayers()[1]));
            //System.out.println(exploitability(optStrategies.get(rootState.getPlayerToMove())));
        }
 }
